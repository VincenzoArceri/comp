module Program

imports Common
imports KBuiltinsBasic
exports

context-free syntax
context-free priorities
{
    "~Int" Int -> Int {cons("Int149Syn")}
} > { left:
    Int "^Int" Int -> Int {left, cons("Int150Syn")}
} > { left:
    Int "*Int" Int -> Int {left, cons("Int152Syn")}
    Int "/Int" Int -> Int {left, cons("Int153Syn")}
    Int "%Int" Int -> Int {left, cons("Int154Syn")}
    Int "divInt" Int -> Int {left, cons("Int155Syn")}
    Int "modInt" Int -> Int {left, cons("Int156Syn")}
} > { left:
    Int "+Int" Int -> Int {left, cons("Int1PlusSyn")}
    Int "-Int" Int -> Int {left, cons("Int157Syn")}
} > { left:
    Int ">>Int" Int -> Int {left, cons("Int158Syn")}
    Int "<<Int" Int -> Int {left, cons("Int159Syn")}
} > { left:
    Int "&Int" Int -> Int {left, cons("Int160Syn")}
} > { left:
    Int "xorInt" Int -> Int {left, cons("Int162Syn")}
} > { left:
    Int "|Int" Int -> Int {left, cons("Int163Syn")}
}

context-free priorities
{
    "notBool" Bool -> Bool {cons("Bool10Syn")}
} > {
    Bool "andBool" Bool -> Bool {left, cons("Bool12Syn")}
    Bool "andThenBool" Bool -> Bool {left, cons("Bool13Syn")}
} > {
    Bool "xorBool" Bool -> Bool {left, cons("Bool14Syn")}
} > {
    Bool "orBool" Bool -> Bool {left, cons("Bool15Syn")}
    Bool "orElseBool" Bool -> Bool {left, cons("Bool16Syn")}
} > {
    Bool "impliesBool" Bool -> Bool {left, cons("Bool17Syn")}
} > { left:
    Bool "==Bool" Bool -> Bool {left, cons("Bool18Syn")}
    Bool "=/=Bool" Bool -> Bool {left, cons("Bool19Syn")}
}

context-free priorities
{
    "--Float" Float -> Float {cons("Float176Syn")}
} > {
    Float "^Float" Float -> Float {left, cons("Float177Syn")}
} > { left:
    Float "*Float" Float -> Float {left, cons("Float178Syn")}
    Float "/Float" Float -> Float {left, cons("Float179Syn")}
    Float "%Float" Float -> Float {left, cons("Float180Syn")}
} > { left:
    Float "+Float" Float -> Float {left, cons("Float182Syn")}
    Float "-Float" Float -> Float {left, cons("Float183Syn")}
}

context-free priorities
{ left:
    Float "<=Float" Float -> Bool {left, cons("Bool184Syn")}
    Float "<Float" Float -> Bool {left, cons("Bool185Syn")}
    Float ">=Float" Float -> Bool {left, cons("Bool186Syn")}
    Float ">Float" Float -> Bool {left, cons("Bool187Syn")}
    Float "==Float" Float -> Bool {left, cons("Bool188Syn")}
    Float "=/=Float" Float -> Bool {left, cons("Bool189Syn")}
} > {
    Float "<=Float" InsertDzFloat "<=Float" Float -> Bool {cons("Bool190Syn")}
}

context-free priorities
{ left:
    K "==K" K -> Bool {left, cons("Bool120Syn")}
    K "=/=K" K -> Bool {left, cons("Bool122Syn")}
}

context-free priorities
{
    K "==K" K -> Bool {left, cons("Bool120Syn")}
    K "=/=K" K -> Bool {left, cons("Bool122Syn")}
} > {
    Bool "impliesBool" Bool -> Bool {left, cons("Bool17Syn")}
    Bool "orBool" Bool -> Bool {left, cons("Bool15Syn")}
    "notBool" Bool -> Bool {cons("Bool10Syn")}
    Bool "xorBool" Bool -> Bool {left, cons("Bool14Syn")}
    Bool "orElseBool" Bool -> Bool {left, cons("Bool16Syn")}
    Bool "andBool" Bool -> Bool {left, cons("Bool12Syn")}
    Bool "andThenBool" Bool -> Bool {left, cons("Bool13Syn")}
}

context-free priorities
{
    Int -> AExp {}
    Id -> AExp {}
    "-" AExp -> AExp {cons("AExp1473Syn")}
} > {
    AExp "/" AExp -> AExp {left, cons("AExp1475Syn")}
    AExp "*" AExp -> AExp {left, cons("AExp1476Syn")}
    AExp "%" AExp -> AExp {left, cons("AExp1477Syn")}
} > {
    AExp "+" AExp -> AExp {left, cons("AExp1478Syn")}
    AExp "-" AExp -> AExp {left, cons("AExp1479Syn")}
}

context-free priorities
{
    Bool -> BExp {}
    AExp "<" AExp -> BExp {non-assoc, cons("BExp1480Syn")}
    AExp "<=" AExp -> BExp {non-assoc, cons("BExp1482Syn")}
    AExp ">" AExp -> BExp {non-assoc, cons("BExp1483Syn")}
    AExp ">=" AExp -> BExp {non-assoc, cons("BExp1484Syn")}
    AExp "==" AExp -> BExp {non-assoc, cons("BExp1485Syn")}
    AExp "!=" AExp -> BExp {non-assoc, cons("BExp1486Syn")}
    "!" BExp -> BExp {cons("BExp1487Syn")}
} > {
    BExp "and" BExp -> BExp {left, cons("BExp1488Syn")}
    BExp "or" BExp -> BExp {left, cons("BExp1489Syn")}
}

context-free start-symbols
Val AExp Variable Set Stmts K String KList Int Stmt Bool Char Ids TCPAnswer DzInt DzString DzBool BExp Bag Ddecl KResult TCPError KLabel Float Block Id Exp Map KItem DzFloat K
context-free syntax
    "isVariable" "(" InsertDzMap ")" -> Bool {cons("Bool1386Syn")}
    "#binderSplit" "(" InsertDzK ")" -> K {cons("K1336Syn")}
    K "[" InsertDzKList "/" InsertDzKList "]" -> K {cons("K1349Syn")}
    AExp -> Exp {}
    "#patternMatch" "(" InsertDzKList "," InsertDzKList ")" -> K {cons("K1308Syn")}
    Exp ";" -> Stmt {cons("Stmt1492Syn")}
    "#freshSubst1" "(" InsertDzSet "," InsertDzSet "," InsertDzMap "," InsertDzK "," InsertDzK ")" -> K {cons("K1367Syn")}
    "ordChar" "(" InsertDzString ")" -> Int {cons("Int198Syn")}
    Map "<=Map" Map -> Bool {cons("Bool130Syn")}
    "SMTLibQuery" "(" InsertDzBool ")" -> String {cons("String1379Syn")}
    "Vars2SMTLib" "(" InsertDzSet ")" -> String {cons("String1377Syn")}
    String "=/=String" String -> Bool {left, cons("Bool1228Syn")}
    "#getSymLabel" "(" InsertDzString ")" -> K {cons("K1394Syn")}
    "#EOF" -> TCPError {cons("TCPError1245Syn")}
    "forall" InsertDzSet "." Bool -> Bool {cons("Bool1374Syn")}
    String "<String" String -> Bool {cons("Bool1229Syn")}
    Map "(" InsertDzK ")" -> K {cons("K1269Syn")}
    "String2Char" "(" InsertDzString ")" -> Char {cons("Char1237Syn")}
    "#map" "(" InsertDzMap ")" -> K {cons("K1278Syn")}
    "isSymbolicBag" "(" InsertDzBag ")" -> K {cons("K1392Syn")}
    "if" "(" InsertDzBExp ")" Block -> Stmt {cons("Stmt1495Syn")}
    "getMatching" "(" InsertDzKList "," InsertDzKList ")" -> Map {cons("Map1306Syn")}
    "intersectSet" "(" InsertDzSet "," InsertDzSet ")" -> Set {cons("Set1286Syn")}
    "#substitutePlainList" "(" InsertDzK "," InsertDzMap ")" -> K {cons("K1369Syn")}
    Bool -> Val {}
    "#freeVarsSet" "(" InsertDzSet ")" -> K {cons("K1342Syn")}
    String "<=String" String -> Bool {cons("Bool1230Syn")}
    String ">=String" String -> Bool {cons("Bool1233Syn")}
    "#hasMapping" "(" InsertDzMap "," InsertDzK ")" -> Bool {cons("Bool1277Syn")}
    "Int2Float" "(" InsertDzInt ")" -> Float {cons("Float192Syn")}
    "Map2KLabel" Map -> KLabel {cons("KLabel1298Syn")}
    "replace" "(" InsertDzString "," InsertDzString "," InsertDzString "," InsertDzInt ")" -> String {cons("String1222Syn")}
    "#isWhiteSpace" "(" InsertDzString ")" -> Bool {cons("Bool1238Syn")}
    "#parseToken" "(" InsertDzString "," InsertDzString ")" -> K {cons("K1240Syn")}
    "#freshVar1" "(" InsertDzSet "," InsertDzK ")" -> K {cons("K1327Syn")}
    "#substituteK" "(" InsertDzK "," InsertDzK ")" -> K {cons("K1352Syn")}
    "maxInt" "(" InsertDzInt "," InsertDzInt ")" -> Int {cons("Int165Syn")}
    "values" Map -> Set {cons("Set1275Syn")}
    "#substitutePlainList1" "(" InsertDzK "," InsertDzMap "," InsertDzKList ")" -> K {cons("K1370Syn")}
    K "#inKList" KList -> Bool {cons("Bool1268Syn")}
    Set "=Set" Set -> Bool {cons("Bool144Syn")}
    "freeVariables" "(" InsertDzSet ")" -> Set {cons("Set1340Syn")}
    KLabel "==KLabel" KLabel -> Bool {cons("Bool137Syn")}
    "#patternMatch1" "(" InsertDzKList "," InsertDzMap ")" -> K {cons("K1309Syn")}
    "read" "(" ")" -> AExp {cons("AExp1474Syn")}
    "SMTCall" "(" InsertDzString ")" -> String {cons("String1380Syn")}
    "#substitute" "(" InsertDzK "," InsertDzMap ")" -> K {cons("K1353Syn")}
    List "=/=List" List -> Bool {cons("Bool140Syn")}
    BExp -> Exp {}
    "#binderSplit1" "(" InsertDzKLabel "," InsertDzInt "," InsertDzKList "," InsertDzKList "," InsertDzKList "," InsertDzSet ")" -> K {cons("K1337Syn")}
    "#freshSymN" "(" InsertDzK "," InsertDzInt ")" -> K {cons("K1397Syn")}
    "$hasMapping" "(" InsertDzMap "," InsertDzK ")" -> Bool {cons("Bool1276Syn")}
    "lengthList" List -> Int {cons("Int1290Syn")}
    KList "=/=KList" KList -> Bool {cons("Bool136Syn")}
    "isBuiltin" "(" InsertDzK ")" -> Bool {cons("Bool1304Syn")}
    "{" InsertDzStmts "}" -> Block {cons("Block1500Syn")}
    Val -> KResult {}
    Map "[" InsertDzMap "]" -> Map {cons("Map1UpdateMapWithMapSyn")}
    "#isMapInK" "(" InsertDzK ")" -> Bool {cons("Bool1279Syn")}
    "#substituteFV" "(" InsertDzK "," InsertDzMap "," InsertDzK ")" -> K {cons("K1354Syn")}
    "#eval" Map -> Bag {cons("Bag1EvalSyn")}
    "trim" "(" InsertDzString ")" -> String {cons("String1225Syn")}
    "#substituteList" "(" InsertDzK "," InsertDzMap "," InsertDzK ")" -> K {cons("K1355Syn")}
    "#boundVars1" "(" InsertDzK ")" -> K {cons("K1335Syn")}
    Map "==Map" Map -> Bool {cons("Bool132Syn")}
    Int "<Int" Int -> Bool {left, cons("Bool168Syn")}
    "#EISDIR" -> TCPError {cons("TCPError1256Syn")}
    "isLocalFreshVar" "(" InsertDzK ")" -> Bool {cons("Bool1328Syn")}
    "KLabel2KLabel" KLabel -> KLabel {cons("KLabel1292Syn")}
    Id -> Variable {}
    DzInt -> Int {}
    K "[" InsertDzMap "]" -> K {cons("K1350Syn")}
    "while" "(" InsertDzBExp ")" Block -> Stmt {cons("Stmt1496Syn")}
    KList "=KList" KList -> Bool {cons("Bool147Syn")}
    "#isDigit" "(" InsertDzString ")" -> Bool {cons("Bool1239Syn")}
    Int "dividesInt" Int -> Bool {cons("Bool175Syn")}
    "countAllOccurences" "(" InsertDzString "," InsertDzString ")" -> Int {cons("Int1224Syn")}
    "Bag2KLabel" Bag -> KLabel {cons("KLabel1295Syn")}
    DzBool -> Bool {}
    K "in" Set -> Bool {cons("Bool1283Syn")}
    "#ESPIPE" -> TCPError {cons("TCPError1255Syn")}
    "#rebind" "(" InsertDzK "," InsertDzK "," InsertDzK "," InsertDzK ")" -> K {cons("K1362Syn")}
    "lengthString" "(" InsertDzString ")" -> Int {cons("Int196Syn")}
    "KList2KLabel" KList -> KLabel {cons("KLabel1294Syn")}
    "#counter" -> Int {cons("Int1266Syn")}
    "findChar" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int1203Syn")}
    "unlock" InsertDzId ";" -> Stmt {cons("Stmt1499Syn")}
    K "inKList" KList -> Bool {cons("Bool1267Syn")}
    String -> TCPAnswer {}
    "#substituteKArrow" "(" InsertDzK "," InsertDzMap "," InsertDzK "," InsertDzK ")" -> K {cons("K1357Syn")}
    "{" "}" -> Block {cons("Block1502Syn")}
    "(" InsertDzAExp ")" -> AExp {cons("AExp1Bracket")}
    "rtrim" "(" InsertDzString ")" -> String {cons("String1227Syn")}
    "isBounding" "(" InsertDzKLabel "," InsertDzInt ")" -> Bool {cons("Bool1330Syn")}
    "#ENOTDIR" -> TCPError {cons("TCPError1249Syn")}
    "String2Id" "(" InsertDzString ")" -> Id {cons("Id1244Syn")}
    "#freshSym" "(" InsertDzK ")" -> K {cons("K1398Syn")}
    "#ENOENT" -> TCPError {cons("TCPError1248Syn")}
    "checkSat" "(" InsertDzBool ")" -> String {cons("String1382Syn")}
    "#ELOOP" -> TCPError {cons("TCPError1252Syn")}
    "#rebind2" "(" InsertDzK "," InsertDzInt "," InsertDzMap "," InsertDzK ")" -> K {cons("K1366Syn")}
    "#isTCPError" "(" InsertDzString ")" -> Bool {cons("Bool1263Syn")}
    "#freezer" K -> KLabel {cons("KLabel1302Syn")}
    "isEmptySet" "(" InsertDzSet ")" -> Bool {cons("Bool1287Syn")}
    "replaceAll" "(" InsertDzString "," InsertDzString "," InsertDzString ")" -> String {cons("String1220Syn")}
    Int -> Val {}
    "#substituteBinder" "(" InsertDzK "," InsertDzMap "," InsertDzK ")" -> K {cons("K1358Syn")}
    "lock" InsertDzId ";" -> Stmt {cons("Stmt1498Syn")}
    "#substitutePlain" "(" InsertDzK "," InsertDzMap ")" -> K {cons("K1368Syn")}
    "chrChar" "(" InsertDzInt ")" -> String {cons("String197Syn")}
    "decomposeMatching" "(" InsertDzKList "," InsertDzKList ")" -> KList {cons("KList1307Syn")}
    Int "<=Int" Int -> Bool {left, cons("Bool167Syn")}
    "#freeVars1" "(" InsertDzKList "," InsertDzK "," InsertDzSet "," InsertDzSet ")" -> K {cons("K1345Syn")}
    "directionalityChar" "(" InsertDzString ")" -> String {cons("String1235Syn")}
    "KLabel2String" "(" InsertDzKLabel ")" -> String {cons("String1209Syn")}
    List "=List" List -> Bool {cons("Bool143Syn")}
    "#getVarsFromK" "(" InsertDzK ")" -> Set {cons("Set1322Syn")}
    "#distinctCounter" "(" InsertDzInt ")" -> Int {cons("Int1265Syn")}
    "isMatching" "(" InsertDzKList "," InsertDzKList ")" -> Bool {cons("Bool1305Syn")}
    Ddecl -> Stmt {}
    Stmts Stmts -> Stmts {right, cons("Stmts1503Syn")}
    Map "[" InsertDzKList "/" InsertDzKList "]" -> Map {cons("Map1273Syn")}
    "#tcpRequest" "(" InsertDzString ")" -> TCPAnswer {cons("TCPAnswer1258Syn")}
    "CellLabel2KLabel" CellLabel -> KLabel {cons("KLabel1293Syn")}
    "#EBADF" -> TCPError {cons("TCPError1254Syn")}
    "#substituteList1" "(" InsertDzK "," InsertDzMap "," InsertDzK "," InsertDzKList ")" -> K {cons("K1356Syn")}
    "isToken" "(" InsertDzK ")" -> Bool {cons("Bool1303Syn")}
    K "inVars" K -> Bool {cons("Bool1333Syn")}
    "getVariables" "(" InsertDzK ")" -> Set {cons("Set1323Syn")}
    List "==List" List -> Bool {cons("Bool139Syn")}
    Map "=/=Map" Map -> Bool {cons("Bool133Syn")}
    "#rebind1" "(" InsertDzK "," InsertDzK ")" -> K {cons("K1365Syn")}
    Set "<=Set" Set -> Bool {cons("Bool127Syn")}
    Int "=Int" Int -> Bool {cons("Bool174Syn")}
    "Consts2SMTLib" "(" InsertDzSet ")" -> String {cons("String1378Syn")}
    "fresh" "(" InsertDzK ")" -> Bool {cons("Bool1FreshSyn")}
    "#evalHelper" Map -> Bag {cons("Bag1EvalHelperSyn")}
    "#ENAMETOOLONG" -> TCPError {cons("TCPError1253Syn")}
    "absInt" "(" InsertDzInt ")" -> Int {cons("Int166Syn")}
    "#freeVars" "(" InsertDzKList "," InsertDzSet "," InsertDzSet ")" -> K {cons("K1344Syn")}
    "dummy" "(" InsertDzKList ")" -> K {cons("K135Syn")}
    "vars" "(" InsertDzSet ")" -> K {cons("K1320Syn")}
    "replaceFirst" "(" InsertDzString "," InsertDzString "," InsertDzString ")" -> String {cons("String1223Syn")}
    "#splitedBinder" "(" InsertDzKList "," InsertDzKList "," InsertDzSet ")" -> K {cons("K1332Syn")}
    "#freeVarsBinder1" "(" InsertDzK "," InsertDzSet ")" -> K {cons("K1347Syn")}
    String "+String" String -> String {left, cons("String194Syn")}
    "#freeVarsBinder2" "(" InsertDzK "," InsertDzK ")" -> K {cons("K1348Syn")}
    "isVariable" "(" InsertDzSet ")" -> Bool {cons("Bool1384Syn")}
    Int "=/=Int" Int -> Bool {left, cons("Bool173Syn")}
    "#getMapFromK" "(" InsertDzK ")" -> Map {cons("Map1280Syn")}
    SetItem "in" Set -> Bool {cons("Bool1284Syn")}
    Int ">Int" Int -> Bool {left, cons("Bool170Syn")}
    "keys" Map -> Set {cons("Set1274Syn")}
    "rfindString" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int1202Syn")}
    "#getVars" "(" InsertDzK ")" -> K {cons("K1324Syn")}
    "#freeVarsBinder" "(" InsertDzK "," InsertDzSet ")" -> K {cons("K1346Syn")}
    "#EINVAL" -> TCPError {cons("TCPError1257Syn")}
    "Int2String" "(" InsertDzInt ")" -> String {cons("String1208Syn")}
    "isSymbolicMap" "(" InsertDzMap ")" -> K {cons("K1393Syn")}
    "#if" InsertDzBool "#then" InsertDzK "#else" InsertDzK "#fi" -> K {cons("K123Syn")}
    Int "==Int" Int -> Bool {left, cons("Bool172Syn")}
    "##tcpRequest" "(" InsertDzString ")" -> String {cons("String1260Syn")}
    "K2Sort" "(" InsertDzK ")" -> String {cons("String1388Syn")}
    K "=K" K -> Bool {cons("Bool142Syn")}
    "List2KLabel" List -> KLabel {cons("KLabel1297Syn")}
    "isVariable" "(" InsertDzBag ")" -> Bool {cons("Bool1385Syn")}
    "spawn" Block -> Stmt {cons("Stmt1490Syn")}
    KLabel "=/=KLabel" KLabel -> Bool {cons("Bool138Syn")}
    "#freshSymSort" "(" InsertDzString ")" -> K {cons("K1396Syn")}
    Bag "=Bag" Bag -> Bool {cons("Bool145Syn")}
    Map "[" "undef" "/" InsertDzKList "]" -> Map {cons("Map1270Syn")}
    "isVariable" "(" InsertDzList ")" -> Bool {cons("Bool1383Syn")}
    Map "=Map" Map -> Bool {cons("Bool146Syn")}
    "Float2Int" "(" InsertDzFloat ")" -> Int {cons("Int193Syn")}
    "#tcpError" "(" InsertDzString ")" -> TCPError {cons("TCPError1246Syn")}
    "randomRandom" "(" InsertDzInt ")" -> Int {cons("Int1264Syn")}
    "substrString" "(" InsertDzString "," InsertDzInt "," InsertDzInt ")" -> String {cons("String199Syn")}
    "findString" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int1200Syn")}
    "String2Int" "(" InsertDzString ")" -> Int {cons("Int1207Syn")}
    "String2KLabel" "(" InsertDzString ")" -> KLabel {cons("KLabel1String2KLabelSyn")}
    "#checkTCPAnswer" "(" InsertDzString ")" -> TCPAnswer {cons("TCPAnswer1259Syn")}
    "#if" InsertDzBool "#then" InsertDzKItem "#else" InsertDzKItem "#fi" -> KItem {cons("KItem124Syn")}
    "#getVars1" "(" InsertDzKList "," InsertDzSet ")" -> K {cons("K1325Syn")}
    String "==String" String -> Bool {left, cons("Bool195Syn")}
    "String2Float" "(" InsertDzString ")" -> Float {cons("Float1206Syn")}
    "isSymbolicSet" "(" InsertDzSet ")" -> K {cons("K1390Syn")}
    "#substMap" "(" InsertDzMap ")" -> K {cons("K1364Syn")}
    "(" InsertDzBExp ")" -> BExp {cons("BExp1Bracket")}
    "#retrieveTCPError" "(" InsertDzString ")" -> String {cons("String1262Syn")}
    "semaphore" InsertDzIds ";" -> Ddecl {cons("Ddecl1472Syn")}
    K "#inSet" Set -> Bool {cons("Bool1285Syn")}
    "Map" "(" InsertDzKList "|->" InsertDzKList ")" -> Map {cons("Map1272Syn")}
    "exists" InsertDzSet "." Bool -> Bool {cons("Bool1375Syn")}
    TCPError -> TCPAnswer {}
    "#" K -> KLabel {cons("KLabel1300Syn")}
    "K2SMTLib" "(" InsertDzK ")" -> String {cons("String1376Syn")}
    "getKLabel" K -> KLabel {cons("KLabel1299Syn")}
    "print" "(" InsertDzAExp ")" ";" -> Stmt {cons("Stmt1497Syn")}
    "#boundVars" "(" InsertDzK ")" -> K {cons("K1334Syn")}
    Stmt -> Stmts {}
    Set "-Set" Set -> Set {cons("Set1282Syn")}
    "#freshSubst" "(" InsertDzSet "," InsertDzSet "," InsertDzMap ")" -> K {cons("K1363Syn")}
    "rfindChar" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int1204Syn")}
    Block -> Stmt {}
    Set "==Set" Set -> Bool {cons("Bool128Syn")}
    DzString -> String {}
    "int" InsertDzIds ";" -> Ddecl {cons("Ddecl1470Syn")}
    "Float2String" "(" InsertDzFloat ")" -> String {cons("String1205Syn")}
    KResult -> K {}
    "isSymbolicList" "(" InsertDzList ")" -> K {cons("K1389Syn")}
    "#freshSymSortN" "(" InsertDzString "," InsertDzInt ")" -> K {cons("K1395Syn")}
    "#binderSplit2" "(" InsertDzKLabel "," InsertDzInt "," InsertDzKList "," InsertDzKList "," InsertDzKList "," InsertDzSet "," InsertDzK ")" -> K {cons("K1338Syn")}
    KLabel "=KLabel" KLabel -> Bool {cons("Bool148Syn")}
    "#EACCES" -> TCPError {cons("TCPError1250Syn")}
    "Set2KLabel" Set -> KLabel {cons("KLabel1296Syn")}
    "isBound" "(" InsertDzKLabel "," InsertDzInt ")" -> Bool {cons("Bool1329Syn")}
    String ">String" String -> Bool {cons("Bool1232Syn")}
    "#substituteBinder2" "(" InsertDzK "," InsertDzMap "," InsertDzK "," InsertDzK ")" -> K {cons("K1360Syn")}
    "#tokenToString" "(" InsertDzK ")" -> String {cons("String1242Syn")}
    "Char2String" "(" InsertDzChar ")" -> String {cons("String1236Syn")}
    "freeVariables" "(" InsertDzKList ")" -> Set {cons("Set1339Syn")}
    "freshVariables" "(" InsertDzSet "," InsertDzK ")" -> K {cons("K1372Syn")}
    "#if" InsertDzBool "#then" InsertDzKList "#else" InsertDzKList "#fi" -> KList {cons("KList125Syn")}
    "minInt" "(" InsertDzInt "," InsertDzInt ")" -> Int {cons("Int164Syn")}
    "ltrim" "(" InsertDzString ")" -> String {cons("String1226Syn")}
    "#if" InsertDzBool "#then" InsertDzInt "#else" InsertDzInt "#fi" -> Int {cons("Int126Syn")}
    "#substituteBinder1" "(" InsertDzK "," InsertDzMap "," InsertDzK "," InsertDzK ")" -> K {cons("K1359Syn")}
    "Set2KTermAcc" "(" InsertDzSet "," InsertDzK ")" -> K {cons("K1289Syn")}
    "Id2String" "(" InsertDzId ")" -> String {cons("String1243Syn")}
    DzFloat -> Float {}
    KList "==KList" KList -> Bool {cons("Bool134Syn")}
    "#freshVar" "(" InsertDzK "," InsertDzSet ")" -> K {cons("K1326Syn")}
    "isKLabelConstant" "(" InsertDzKLabel ")" -> Bool {cons("Bool1387Syn")}
    "#changeLabel" "(" InsertDzK "," InsertDzK ")" -> K {cons("K1373Syn")}
    Set "=/=Set" Set -> Bool {cons("Bool129Syn")}
    "#freeVars" "(" InsertDzKList ")" -> K {cons("K1343Syn")}
    Int ">=Int" Int -> Bool {left, cons("Bool169Syn")}
    "Set2KTerm" "(" InsertDzSet ")" -> K {cons("K1288Syn")}
    Id "=" InsertDzAExp ";" -> Stmt {cons("Stmt1493Syn")}
    "categoryChar" "(" InsertDzString ")" -> String {cons("String1234Syn")}
    "#noparse" -> TCPError {cons("TCPError1247Syn")}
    "if" "(" InsertDzBExp ")" InsertDzBlock "else" Block -> Stmt {cons("Stmt1494Syn")}
    {Id ","}* -> Ids {cons("Ids1ListSyn")}
    AExp -> InsertDzAExp
    Set -> InsertDzSet
    Stmts -> InsertDzStmts
    BExp -> InsertDzBExp
    Bag -> InsertDzBag
    K -> InsertDzK
    String -> InsertDzString
    KList -> InsertDzKList
    Int -> InsertDzInt
    Float -> InsertDzFloat
    KLabel -> InsertDzKLabel
    Bool -> InsertDzBool
    Char -> InsertDzChar
    Ids -> InsertDzIds
    Block -> InsertDzBlock
    List -> InsertDzList
    Id -> InsertDzId
    Map -> InsertDzMap
    KItem -> InsertDzKItem


    DzDzString        -> DzString    {cons("DzString1Const")}
    DzDzBool        -> DzBool    {cons("DzBool1Const")}
    DzKLabel        -> KLabel    {cons("KLabel1Const")}
    DzDzInt        -> DzInt    {cons("DzInt1Const")}
    DzDzId        -> DzId    {cons("DzId1Const")}
    DzDzFloat        -> DzFloat    {cons("DzFloat1Const")}



%% start symbols subsorts
    KItem        -> K
    Val        -> K
    AExp        -> K
    Variable        -> K
    Stmts        -> K
    String        -> K
    Int        -> K
    Stmt        -> K
    Bool        -> K
    Char        -> K
    TCPAnswer        -> K
    DzInt        -> K
    DzString        -> K
    DzBool        -> K
    BExp        -> K
    Ddecl        -> K
    TCPError        -> K
    Float        -> K
    Block        -> K
    Id        -> K
    Exp        -> K
    DzFloat        -> K
lexical syntax
    "redex" -> DzKLabel
    "#set" -> DzKLabel
    "isBinder" -> DzKLabel
    "false" -> DzDzBool
    "wrap-with" -> DzKLabel
    "'#andBool" -> DzKLabel
    "isKResult" -> DzKLabel
    "heat" -> DzKLabel
    "isSet" -> DzKLabel
    "cool" -> DzKLabel
    "heated" -> DzKLabel
    "#token" -> DzKLabel
    "true" -> DzDzBool
    "#symEqualitySort" -> DzKLabel


    "directionalityChar" -> IdDz {reject}
    "trim" -> IdDz {reject}
    "categoryChar" -> IdDz {reject}
    "isSymbolicSet" -> IdDz {reject}
    "isBinder" -> IdDz {reject}
    "vars" -> IdDz {reject}
    "checkSat" -> IdDz {reject}
    "ordChar" -> IdDz {reject}
    "Int2Float" -> IdDz {reject}
    "getKLabel" -> IdDz {reject}
    "semaphore" -> IdDz {reject}
    "isLocalFreshVar" -> IdDz {reject}
    "getVariables" -> IdDz {reject}
    "replaceFirst" -> IdDz {reject}
    "isBounding" -> IdDz {reject}
    "KLabel2String" -> IdDz {reject}
    "xorBool" -> IdDz {reject}
    "maxInt" -> IdDz {reject}
    "forall" -> IdDz {reject}
    "undef" -> IdDz {reject}
    "SMTCall" -> IdDz {reject}
    "isKResult" -> IdDz {reject}
    "xorInt" -> IdDz {reject}
    "notBool" -> IdDz {reject}
    "Map2KLabel" -> IdDz {reject}
    "lengthString" -> IdDz {reject}
    "unlock" -> IdDz {reject}
    "ltrim" -> IdDz {reject}
    "isBuiltin" -> IdDz {reject}
    "orBool" -> IdDz {reject}
    "isSymbolicBag" -> IdDz {reject}
    "replaceAll" -> IdDz {reject}
    "Set2KTerm" -> IdDz {reject}
    "rfindChar" -> IdDz {reject}
    "intersectSet" -> IdDz {reject}
    "false" -> IdDz {reject}
    "String2Int" -> IdDz {reject}
    "print" -> IdDz {reject}
    "isBound" -> IdDz {reject}
    "Bag2KLabel" -> IdDz {reject}
    "fresh" -> IdDz {reject}
    "getMatching" -> IdDz {reject}
    "K2SMTLib" -> IdDz {reject}
    "rfindString" -> IdDz {reject}
    "freshVariables" -> IdDz {reject}
    "Float2Int" -> IdDz {reject}
    "dummy" -> IdDz {reject}
    "isSymbolicMap" -> IdDz {reject}
    "Set2KTermAcc" -> IdDz {reject}
    "findString" -> IdDz {reject}
    "dividesInt" -> IdDz {reject}
    "else" -> IdDz {reject}
    "lock" -> IdDz {reject}
    "if" -> IdDz {reject}
    "isSet" -> IdDz {reject}
    "in" -> IdDz {reject}
    "Float2String" -> IdDz {reject}
    "decomposeMatching" -> IdDz {reject}
    "isKLabelConstant" -> IdDz {reject}
    "isMatching" -> IdDz {reject}
    "CellLabel2KLabel" -> IdDz {reject}
    "String2Id" -> IdDz {reject}
    "isSymbolicList" -> IdDz {reject}
    "divInt" -> IdDz {reject}
    "absInt" -> IdDz {reject}
    "Map" -> IdDz {reject}
    "chrChar" -> IdDz {reject}
    "randomRandom" -> IdDz {reject}
    "isEmptySet" -> IdDz {reject}
    "KList2KLabel" -> IdDz {reject}
    "K2Sort" -> IdDz {reject}
    "cool" -> IdDz {reject}
    "freeVariables" -> IdDz {reject}
    "redex" -> IdDz {reject}
    "String2Float" -> IdDz {reject}
    "exists" -> IdDz {reject}
    "impliesBool" -> IdDz {reject}
    "SMTLibQuery" -> IdDz {reject}
    "andThenBool" -> IdDz {reject}
    "List2KLabel" -> IdDz {reject}
    "replace" -> IdDz {reject}
    "lengthList" -> IdDz {reject}
    "String2KLabel" -> IdDz {reject}
    "while" -> IdDz {reject}
    "isToken" -> IdDz {reject}
    "inVars" -> IdDz {reject}
    "substrString" -> IdDz {reject}
    "Vars2SMTLib" -> IdDz {reject}
    "countAllOccurences" -> IdDz {reject}
    "KLabel2KLabel" -> IdDz {reject}
    "read" -> IdDz {reject}
    "Int2String" -> IdDz {reject}
    "Consts2SMTLib" -> IdDz {reject}
    "true" -> IdDz {reject}
    "heated" -> IdDz {reject}
    "Char2String" -> IdDz {reject}
    "Set2KLabel" -> IdDz {reject}
    "heat" -> IdDz {reject}
    "String2Char" -> IdDz {reject}
    "modInt" -> IdDz {reject}
    "minInt" -> IdDz {reject}
    "keys" -> IdDz {reject}
    "values" -> IdDz {reject}
    "orElseBool" -> IdDz {reject}
    "findChar" -> IdDz {reject}
    "and" -> IdDz {reject}
    "Id2String" -> IdDz {reject}
    "or" -> IdDz {reject}
    "rtrim" -> IdDz {reject}
    "inKList" -> IdDz {reject}
    "int" -> IdDz {reject}
    "andBool" -> IdDz {reject}
    "spawn" -> IdDz {reject}
    "isVariable" -> IdDz {reject}

lexical restrictions
    %% follow restrictions
    "#substitute" -/- [P].[l].[a].[i].[n].[L].[i].[s].[t]
    "or" -/- [B].[o].[o].[l]
    "=" -/- [M].[a].[p]
    "#" -/- [E].[B].[A].[D].[F]
    "#" -/- [E].[I].[S].[D].[I].[R]
    "#token" -/- [T].[o].[S].[t].[r].[i].[n].[g]
    "-" -/- [F].[l].[o].[a].[t]
    "#freshSym" -/- [S].[o].[r].[t]
    "#" -/- [E].[S].[P].[I].[P].[E]
    "#" -/- [E].[N].[O].[T].[D].[I].[R]
    "and" -/- [T].[h].[e].[n].[B].[o].[o].[l]
    ">" -/- [I].[n].[t]
    "#substitute" -/- [P].[l].[a].[i].[n].[L].[i].[s].[t].[\1]
    "=" -/- [K].[L].[a].[b].[e].[l]
    "#substitutePlain" -/- [L].[i].[s].[t].[\1]
    "<" -/- [S].[t].[r].[i].[n].[g]
    "#freeVars" -/- [S].[e].[t]
    "#" -/- [E].[N].[A].[M].[E].[T].[O].[O].[L].[O].[N].[G]
    "*" -/- [I].[n].[t]
    "=K" -/- [L].[a].[b].[e].[l]
    "+" -/- [S].[t].[r].[i].[n].[g]
    "#substitute" -/- [L].[i].[s].[t]
    "=/=K" -/- [L].[a].[b].[e].[l]
    ">" -/- [F].[l].[o].[a].[t]
    "or" -/- [E].[l].[s].[e].[B].[o].[o].[l]
    "#substitute" -/- [P].[l].[a].[i].[n]
    "and" -/- [B].[o].[o].[l]
    "==K" -/- [L].[i].[s].[t]
    "fresh" -/- [V].[a].[r].[i].[a].[b].[l].[e].[s]
    "<=" -/- [S].[t].[r].[i].[n].[g]
    "==" -/- [K].[L].[i].[s].[t]
    "#substitute" -/- [B].[i].[n].[d].[e].[r]
    "=" -/- [I].[n].[t]
    "#substitute" -/- [B].[i].[n].[d].[e].[r].[\1]
    "-" -/- [S].[e].[t]
    "==" -/- [I].[n].[t]
    "#substitute" -/- [B].[i].[n].[d].[e].[r].[\2]
    "-" -/- [I].[n].[t]
    "==" -/- [S].[e].[t]
    "replace" -/- [A].[l].[l]
    "==" -/- [F].[l].[o].[a].[t]
    "=" -/- [S].[e].[t]
    "%" -/- [I].[n].[t]
    "in" -/- [K].[L].[i].[s].[t]
    "replace" -/- [F].[i].[r].[s].[t]
    "Set2KTerm" -/- [A].[c].[c]
    "==" -/- [M].[a].[p]
    "*" -/- [F].[l].[o].[a].[t]
    "<=" -/- [I].[n].[t]
    "=K" -/- [L].[i].[s].[t]
    "<=" -/- [F].[l].[o].[a].[t]
    "=" -/- [L].[i].[s].[t]
    "<=" -/- [S].[e].[t]
    "#substitute" -/- [K]
    "#substitute" -/- [F].[V]
    "==" -/- [K]
    "#freshSymSort" -/- [N]
    "#freshSym" -/- [N]
    "==" -/- [S].[t].[r].[i].[n].[g]
    ">" -/- [S].[t].[r].[i].[n].[g]
    "<" -/- [I].[n].[t]
    "<" -/- [F].[l].[o].[a].[t]
    "=" -/- [B].[a].[g]
    "==" -/- [B].[o].[o].[l]
    "#substitute" -/- [K].[A].[r].[r].[o].[w]
    "#freeVars" -/- [B].[i].[n].[d].[e].[r]
    "=/=K" -/- [L].[i].[s].[t]
    "#" -/- [E].[A].[C].[C].[E].[S]
    "/" -/- [F].[l].[o].[a].[t]
    "#" -/- [E].[L].[O].[O].[P]
    "#" -/- [E].[N].[O].[E].[N].[T]
    "#freeVars" -/- [B].[i].[n].[d].[e].[r].[\1]
    "==K" -/- [L].[a].[b].[e].[l]
    ">=" -/- [I].[n].[t]
    "#freeVars" -/- [B].[i].[n].[d].[e].[r].[\2]
    "#freshSym" -/- [S].[o].[r].[t].[N]
    "==" -/- [L].[i].[s].[t]
    "=" -/- [K]
    "%" -/- [F].[l].[o].[a].[t]
    "#" -/- [E].[O].[F]
    "#substitutePlain" -/- [L].[i].[s].[t]
    ">=" -/- [S].[t].[r].[i].[n].[g]
    "+" -/- [F].[l].[o].[a].[t]
    "==" -/- [K].[L].[a].[b].[e].[l]
    "#eval" -/- [H].[e].[l].[p].[e].[r]
    "#substitute" -/- [L].[i].[s].[t].[\1]
    "=" -/- [K].[L].[i].[s].[t]
    "in" -/- [V].[a].[r].[s]
    "#getVars" -/- [F].[r].[o].[m].[K]
    "<=" -/- [M].[a].[p]
    "#substituteK" -/- [A].[r].[r].[o].[w]
    "/" -/- [I].[n].[t]
    ">=" -/- [F].[l].[o].[a].[t]
    "+" -/- [I].[n].[t]
    "#" -/- [E].[I].[N].[V].[A].[L]


lexical syntax
    [\-\+]?[0-9]+ -> DzIntDz
    "\"" ((~[\"\n\r\\])|(((([\\][nrtf\"\\])|([\\][x][0-9a-fA-F][0-9a-fA-F]))|([\\][u][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]))|([\\][U][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])))*"\"" -> DzStringDz
    [\+\-]?[0-9]+"."[0-9]+([eE][\+\-]?[0-9]+)?[fFdD]? -> DzFloatDz
    [A-Za-z\_][A-Za-z0-9\_]* -> IdDz
    "directionalityChar" -> DzStringDz {reject}
    "%Float" -> DzStringDz {reject}
    "#getVarsFromK" -> DzStringDz {reject}
    "<Int" -> DzStringDz {reject}
    ">String" -> DzStringDz {reject}
    "trim" -> DzStringDz {reject}
    "categoryChar" -> DzStringDz {reject}
    "isSymbolicSet" -> DzStringDz {reject}
    "#evalHelper" -> DzStringDz {reject}
    "isBinder" -> DzStringDz {reject}
    "#substituteBinder" -> DzStringDz {reject}
    "#binderSplit1" -> DzStringDz {reject}
    "vars" -> DzStringDz {reject}
    "#binderSplit2" -> DzStringDz {reject}
    "#freeVars1" -> DzStringDz {reject}
    "!" -> DzStringDz {reject}
    "#" -> DzStringDz {reject}
    "checkSat" -> DzStringDz {reject}
    "%" -> DzStringDz {reject}
    "#fi" -> DzStringDz {reject}
    "(" -> DzStringDz {reject}
    ")" -> DzStringDz {reject}
    "ordChar" -> DzStringDz {reject}
    "*" -> DzStringDz {reject}
    "+" -> DzStringDz {reject}
    "," -> DzStringDz {reject}
    "-" -> DzStringDz {reject}
    "." -> DzStringDz {reject}
    "Int2Float" -> DzStringDz {reject}
    "/" -> DzStringDz {reject}
    "#inKList" -> DzStringDz {reject}
    "getKLabel" -> DzStringDz {reject}
    ">=Int" -> DzStringDz {reject}
    "=/=KList" -> DzStringDz {reject}
    "semaphore" -> DzStringDz {reject}
    ">=Float" -> DzStringDz {reject}
    ";" -> DzStringDz {reject}
    "<" -> DzStringDz {reject}
    "!=" -> DzStringDz {reject}
    "isLocalFreshVar" -> DzStringDz {reject}
    "=" -> DzStringDz {reject}
    ">" -> DzStringDz {reject}
    "#symEqualitySort" -> DzStringDz {reject}
    "getVariables" -> DzStringDz {reject}
    "#freshVar" -> DzStringDz {reject}
    "#tcpError" -> DzStringDz {reject}
    "#map" -> DzStringDz {reject}
    "replaceFirst" -> DzStringDz {reject}
    "<=Set" -> DzStringDz {reject}
    "isBounding" -> DzStringDz {reject}
    "KLabel2String" -> DzStringDz {reject}
    "#getVars" -> DzStringDz {reject}
    "#getVars1" -> DzStringDz {reject}
    "[" -> DzStringDz {reject}
    "]" -> DzStringDz {reject}
    "xorBool" -> DzStringDz {reject}
    "#substitutePlainList" -> DzStringDz {reject}
    "maxInt" -> DzStringDz {reject}
    "forall" -> DzStringDz {reject}
    "undef" -> DzStringDz {reject}
    "=Int" -> DzStringDz {reject}
    "==String" -> DzStringDz {reject}
    "#freeVars" -> DzStringDz {reject}
    "SMTCall" -> DzStringDz {reject}
    "#freshSubst1" -> DzStringDz {reject}
    "#noparse" -> DzStringDz {reject}
    "#boundVars1" -> DzStringDz {reject}
    "#patternMatch1" -> DzStringDz {reject}
    "{" -> DzStringDz {reject}
    "}" -> DzStringDz {reject}
    "isKResult" -> DzStringDz {reject}
    "#if" -> DzStringDz {reject}
    "xorInt" -> DzStringDz {reject}
    "notBool" -> DzStringDz {reject}
    "Map2KLabel" -> DzStringDz {reject}
    "#freeVarsBinder" -> DzStringDz {reject}
    "-Int" -> DzStringDz {reject}
    "=Bag" -> DzStringDz {reject}
    "#freshSymSort" -> DzStringDz {reject}
    "lengthString" -> DzStringDz {reject}
    "#counter" -> DzStringDz {reject}
    "##tcpRequest" -> DzStringDz {reject}
    "^Int" -> DzStringDz {reject}
    "#freeVarsBinder1" -> DzStringDz {reject}
    "#freeVarsBinder2" -> DzStringDz {reject}
    "#substituteBinder1" -> DzStringDz {reject}
    "#substituteBinder2" -> DzStringDz {reject}
    "#substMap" -> DzStringDz {reject}
    "#isTCPError" -> DzStringDz {reject}
    "#EISDIR" -> DzStringDz {reject}
    "unlock" -> DzStringDz {reject}
    "#isMapInK" -> DzStringDz {reject}
    "ltrim" -> DzStringDz {reject}
    "=/=List" -> DzStringDz {reject}
    "#patternMatch" -> DzStringDz {reject}
    "~Int" -> DzStringDz {reject}
    "==K" -> DzStringDz {reject}
    "isBuiltin" -> DzStringDz {reject}
    "#ENOTDIR" -> DzStringDz {reject}
    "#freshSymSortN" -> DzStringDz {reject}
    "#changeLabel" -> DzStringDz {reject}
    "=/=Map" -> DzStringDz {reject}
    "orBool" -> DzStringDz {reject}
    "isSymbolicBag" -> DzStringDz {reject}
    "$hasMapping" -> DzStringDz {reject}
    "#isDigit" -> DzStringDz {reject}
    ">Int" -> DzStringDz {reject}
    "replaceAll" -> DzStringDz {reject}
    "#ESPIPE" -> DzStringDz {reject}
    "==KList" -> DzStringDz {reject}
    "==KLabel" -> DzStringDz {reject}
    "=KLabel" -> DzStringDz {reject}
    "Set2KTerm" -> DzStringDz {reject}
    "rfindChar" -> DzStringDz {reject}
    "#isWhiteSpace" -> DzStringDz {reject}
    "=/=K" -> DzStringDz {reject}
    "intersectSet" -> DzStringDz {reject}
    "-Set" -> DzStringDz {reject}
    "#tokenToString" -> DzStringDz {reject}
    "#then" -> DzStringDz {reject}
    "#splitedBinder" -> DzStringDz {reject}
    "==Map" -> DzStringDz {reject}
    "#substituteK" -> DzStringDz {reject}
    "false" -> DzStringDz {reject}
    "^Float" -> DzStringDz {reject}
    "String2Int" -> DzStringDz {reject}
    "#freshSubst" -> DzStringDz {reject}
    "print" -> DzStringDz {reject}
    "#freezer" -> DzStringDz {reject}
    "isBound" -> DzStringDz {reject}
    "Bag2KLabel" -> DzStringDz {reject}
    "-Float" -> DzStringDz {reject}
    "#distinctCounter" -> DzStringDz {reject}
    "=Set" -> DzStringDz {reject}
    "+String" -> DzStringDz {reject}
    "#substitutePlainList1" -> DzStringDz {reject}
    "fresh" -> DzStringDz {reject}
    "=/=Bool" -> DzStringDz {reject}
    "getMatching" -> DzStringDz {reject}
    "K2SMTLib" -> DzStringDz {reject}
    "=List" -> DzStringDz {reject}
    "#checkTCPAnswer" -> DzStringDz {reject}
    "rfindString" -> DzStringDz {reject}
    "#substitutePlain" -> DzStringDz {reject}
    "#inSet" -> DzStringDz {reject}
    "freshVariables" -> DzStringDz {reject}
    "Float2Int" -> DzStringDz {reject}
    "dummy" -> DzStringDz {reject}
    "isSymbolicMap" -> DzStringDz {reject}
    "Set2KTermAcc" -> DzStringDz {reject}
    "#retrieveTCPError" -> DzStringDz {reject}
    "findString" -> DzStringDz {reject}
    "dividesInt" -> DzStringDz {reject}
    "else" -> DzStringDz {reject}
    "lock" -> DzStringDz {reject}
    "#EINVAL" -> DzStringDz {reject}
    "if" -> DzStringDz {reject}
    "=/=Float" -> DzStringDz {reject}
    "#eval" -> DzStringDz {reject}
    "isSet" -> DzStringDz {reject}
    "in" -> DzStringDz {reject}
    "<<Int" -> DzStringDz {reject}
    "#EBADF" -> DzStringDz {reject}
    "Float2String" -> DzStringDz {reject}
    "decomposeMatching" -> DzStringDz {reject}
    "|->" -> DzStringDz {reject}
    "isKLabelConstant" -> DzStringDz {reject}
    "isMatching" -> DzStringDz {reject}
    "/Float" -> DzStringDz {reject}
    "<=String" -> DzStringDz {reject}
    ">=String" -> DzStringDz {reject}
    "CellLabel2KLabel" -> DzStringDz {reject}
    "=KList" -> DzStringDz {reject}
    "String2Id" -> DzStringDz {reject}
    "#getMapFromK" -> DzStringDz {reject}
    "==Bool" -> DzStringDz {reject}
    "isSymbolicList" -> DzStringDz {reject}
    "divInt" -> DzStringDz {reject}
    "absInt" -> DzStringDz {reject}
    "Map" -> DzStringDz {reject}
    "#ENAMETOOLONG" -> DzStringDz {reject}
    "<=Float" -> DzStringDz {reject}
    "chrChar" -> DzStringDz {reject}
    "randomRandom" -> DzStringDz {reject}
    "wrap-with" -> DzStringDz {reject}
    "#set" -> DzStringDz {reject}
    "isEmptySet" -> DzStringDz {reject}
    "/Int" -> DzStringDz {reject}
    "==Int" -> DzStringDz {reject}
    "KList2KLabel" -> DzStringDz {reject}
    "#parseToken" -> DzStringDz {reject}
    "<String" -> DzStringDz {reject}
    "=/=String" -> DzStringDz {reject}
    "#hasMapping" -> DzStringDz {reject}
    "K2Sort" -> DzStringDz {reject}
    "#EACCES" -> DzStringDz {reject}
    "cool" -> DzStringDz {reject}
    "freeVariables" -> DzStringDz {reject}
    ">Float" -> DzStringDz {reject}
    "#rebind" -> DzStringDz {reject}
    "#boundVars" -> DzStringDz {reject}
    "*Int" -> DzStringDz {reject}
    "redex" -> DzStringDz {reject}
    "<=Map" -> DzStringDz {reject}
    "String2Float" -> DzStringDz {reject}
    "exists" -> DzStringDz {reject}
    "#freshSymN" -> DzStringDz {reject}
    "impliesBool" -> DzStringDz {reject}
    "SMTLibQuery" -> DzStringDz {reject}
    "andThenBool" -> DzStringDz {reject}
    "#rebind2" -> DzStringDz {reject}
    "#ENOENT" -> DzStringDz {reject}
    "#rebind1" -> DzStringDz {reject}
    "<=" -> DzStringDz {reject}
    "List2KLabel" -> DzStringDz {reject}
    ">>Int" -> DzStringDz {reject}
    "replace" -> DzStringDz {reject}
    "lengthList" -> DzStringDz {reject}
    "String2KLabel" -> DzStringDz {reject}
    "while" -> DzStringDz {reject}
    "#ELOOP" -> DzStringDz {reject}
    "isToken" -> DzStringDz {reject}
    "inVars" -> DzStringDz {reject}
    "substrString" -> DzStringDz {reject}
    "Vars2SMTLib" -> DzStringDz {reject}
    "#getSymLabel" -> DzStringDz {reject}
    "%Int" -> DzStringDz {reject}
    "+Float" -> DzStringDz {reject}
    "==Float" -> DzStringDz {reject}
    "countAllOccurences" -> DzStringDz {reject}
    "==" -> DzStringDz {reject}
    "KLabel2KLabel" -> DzStringDz {reject}
    "read" -> DzStringDz {reject}
    "#freshSym" -> DzStringDz {reject}
    "Int2String" -> DzStringDz {reject}
    "#substituteFV" -> DzStringDz {reject}
    "=K" -> DzStringDz {reject}
    "Consts2SMTLib" -> DzStringDz {reject}
    "true" -> DzStringDz {reject}
    "heated" -> DzStringDz {reject}
    "Char2String" -> DzStringDz {reject}
    "#substituteList" -> DzStringDz {reject}
    "=/=Set" -> DzStringDz {reject}
    "Set2KLabel" -> DzStringDz {reject}
    ">=" -> DzStringDz {reject}
    "heat" -> DzStringDz {reject}
    "#else" -> DzStringDz {reject}
    "=Map" -> DzStringDz {reject}
    "<=Int" -> DzStringDz {reject}
    "String2Char" -> DzStringDz {reject}
    "modInt" -> DzStringDz {reject}
    "minInt" -> DzStringDz {reject}
    "keys" -> DzStringDz {reject}
    "values" -> DzStringDz {reject}
    "orElseBool" -> DzStringDz {reject}
    "==List" -> DzStringDz {reject}
    "#EOF" -> DzStringDz {reject}
    "#freeVarsSet" -> DzStringDz {reject}
    "'#andBool" -> DzStringDz {reject}
    "=/=KLabel" -> DzStringDz {reject}
    "=/=Int" -> DzStringDz {reject}
    "+Int" -> DzStringDz {reject}
    "findChar" -> DzStringDz {reject}
    "--Float" -> DzStringDz {reject}
    "and" -> DzStringDz {reject}
    "==Set" -> DzStringDz {reject}
    "#substituteList1" -> DzStringDz {reject}
    "#tcpRequest" -> DzStringDz {reject}
    "Id2String" -> DzStringDz {reject}
    "or" -> DzStringDz {reject}
    "#substitute" -> DzStringDz {reject}
    "#token" -> DzStringDz {reject}
    "rtrim" -> DzStringDz {reject}
    "|Int" -> DzStringDz {reject}
    "*Float" -> DzStringDz {reject}
    "inKList" -> DzStringDz {reject}
    "int" -> DzStringDz {reject}
    "<Float" -> DzStringDz {reject}
    "andBool" -> DzStringDz {reject}
    "spawn" -> DzStringDz {reject}
    "isVariable" -> DzStringDz {reject}
    "&Int" -> DzStringDz {reject}
    "#binderSplit" -> DzStringDz {reject}
    "#freshVar1" -> DzStringDz {reject}
    "#substituteKArrow" -> DzStringDz {reject}
    "directionalityChar" -> IdDz {reject}
    "%Float" -> IdDz {reject}
    "#getVarsFromK" -> IdDz {reject}
    "<Int" -> IdDz {reject}
    ">String" -> IdDz {reject}
    "trim" -> IdDz {reject}
    "categoryChar" -> IdDz {reject}
    "isSymbolicSet" -> IdDz {reject}
    "#evalHelper" -> IdDz {reject}
    "isBinder" -> IdDz {reject}
    "#substituteBinder" -> IdDz {reject}
    "#binderSplit1" -> IdDz {reject}
    "vars" -> IdDz {reject}
    "#binderSplit2" -> IdDz {reject}
    "#freeVars1" -> IdDz {reject}
    "!" -> IdDz {reject}
    "#" -> IdDz {reject}
    "checkSat" -> IdDz {reject}
    "%" -> IdDz {reject}
    "#fi" -> IdDz {reject}
    "(" -> IdDz {reject}
    ")" -> IdDz {reject}
    "ordChar" -> IdDz {reject}
    "*" -> IdDz {reject}
    "+" -> IdDz {reject}
    "," -> IdDz {reject}
    "-" -> IdDz {reject}
    "." -> IdDz {reject}
    "Int2Float" -> IdDz {reject}
    "/" -> IdDz {reject}
    "#inKList" -> IdDz {reject}
    "getKLabel" -> IdDz {reject}
    ">=Int" -> IdDz {reject}
    "=/=KList" -> IdDz {reject}
    "semaphore" -> IdDz {reject}
    ">=Float" -> IdDz {reject}
    ";" -> IdDz {reject}
    "<" -> IdDz {reject}
    "!=" -> IdDz {reject}
    "isLocalFreshVar" -> IdDz {reject}
    "=" -> IdDz {reject}
    ">" -> IdDz {reject}
    "#symEqualitySort" -> IdDz {reject}
    "getVariables" -> IdDz {reject}
    "#freshVar" -> IdDz {reject}
    "#tcpError" -> IdDz {reject}
    "#map" -> IdDz {reject}
    "replaceFirst" -> IdDz {reject}
    "<=Set" -> IdDz {reject}
    "isBounding" -> IdDz {reject}
    "KLabel2String" -> IdDz {reject}
    "#getVars" -> IdDz {reject}
    "#getVars1" -> IdDz {reject}
    "[" -> IdDz {reject}
    "]" -> IdDz {reject}
    "xorBool" -> IdDz {reject}
    "#substitutePlainList" -> IdDz {reject}
    "maxInt" -> IdDz {reject}
    "forall" -> IdDz {reject}
    "undef" -> IdDz {reject}
    "=Int" -> IdDz {reject}
    "==String" -> IdDz {reject}
    "#freeVars" -> IdDz {reject}
    "SMTCall" -> IdDz {reject}
    "#freshSubst1" -> IdDz {reject}
    "#noparse" -> IdDz {reject}
    "#boundVars1" -> IdDz {reject}
    "#patternMatch1" -> IdDz {reject}
    "{" -> IdDz {reject}
    "}" -> IdDz {reject}
    "isKResult" -> IdDz {reject}
    "#if" -> IdDz {reject}
    "xorInt" -> IdDz {reject}
    "notBool" -> IdDz {reject}
    "Map2KLabel" -> IdDz {reject}
    "#freeVarsBinder" -> IdDz {reject}
    "-Int" -> IdDz {reject}
    "=Bag" -> IdDz {reject}
    "#freshSymSort" -> IdDz {reject}
    "lengthString" -> IdDz {reject}
    "#counter" -> IdDz {reject}
    "##tcpRequest" -> IdDz {reject}
    "^Int" -> IdDz {reject}
    "#freeVarsBinder1" -> IdDz {reject}
    "#freeVarsBinder2" -> IdDz {reject}
    "#substituteBinder1" -> IdDz {reject}
    "#substituteBinder2" -> IdDz {reject}
    "#substMap" -> IdDz {reject}
    "#isTCPError" -> IdDz {reject}
    "#EISDIR" -> IdDz {reject}
    "unlock" -> IdDz {reject}
    "#isMapInK" -> IdDz {reject}
    "ltrim" -> IdDz {reject}
    "=/=List" -> IdDz {reject}
    "#patternMatch" -> IdDz {reject}
    "~Int" -> IdDz {reject}
    "==K" -> IdDz {reject}
    "isBuiltin" -> IdDz {reject}
    "#ENOTDIR" -> IdDz {reject}
    "#freshSymSortN" -> IdDz {reject}
    "#changeLabel" -> IdDz {reject}
    "=/=Map" -> IdDz {reject}
    "orBool" -> IdDz {reject}
    "isSymbolicBag" -> IdDz {reject}
    "$hasMapping" -> IdDz {reject}
    "#isDigit" -> IdDz {reject}
    ">Int" -> IdDz {reject}
    "replaceAll" -> IdDz {reject}
    "#ESPIPE" -> IdDz {reject}
    "==KList" -> IdDz {reject}
    "==KLabel" -> IdDz {reject}
    "=KLabel" -> IdDz {reject}
    "Set2KTerm" -> IdDz {reject}
    "rfindChar" -> IdDz {reject}
    "#isWhiteSpace" -> IdDz {reject}
    "=/=K" -> IdDz {reject}
    "intersectSet" -> IdDz {reject}
    "-Set" -> IdDz {reject}
    "#tokenToString" -> IdDz {reject}
    "#then" -> IdDz {reject}
    "#splitedBinder" -> IdDz {reject}
    "==Map" -> IdDz {reject}
    "#substituteK" -> IdDz {reject}
    "false" -> IdDz {reject}
    "^Float" -> IdDz {reject}
    "String2Int" -> IdDz {reject}
    "#freshSubst" -> IdDz {reject}
    "print" -> IdDz {reject}
    "#freezer" -> IdDz {reject}
    "isBound" -> IdDz {reject}
    "Bag2KLabel" -> IdDz {reject}
    "-Float" -> IdDz {reject}
    "#distinctCounter" -> IdDz {reject}
    "=Set" -> IdDz {reject}
    "+String" -> IdDz {reject}
    "#substitutePlainList1" -> IdDz {reject}
    "fresh" -> IdDz {reject}
    "=/=Bool" -> IdDz {reject}
    "getMatching" -> IdDz {reject}
    "K2SMTLib" -> IdDz {reject}
    "=List" -> IdDz {reject}
    "#checkTCPAnswer" -> IdDz {reject}
    "rfindString" -> IdDz {reject}
    "#substitutePlain" -> IdDz {reject}
    "#inSet" -> IdDz {reject}
    "freshVariables" -> IdDz {reject}
    "Float2Int" -> IdDz {reject}
    "dummy" -> IdDz {reject}
    "isSymbolicMap" -> IdDz {reject}
    "Set2KTermAcc" -> IdDz {reject}
    "#retrieveTCPError" -> IdDz {reject}
    "findString" -> IdDz {reject}
    "dividesInt" -> IdDz {reject}
    "else" -> IdDz {reject}
    "lock" -> IdDz {reject}
    "#EINVAL" -> IdDz {reject}
    "if" -> IdDz {reject}
    "=/=Float" -> IdDz {reject}
    "#eval" -> IdDz {reject}
    "isSet" -> IdDz {reject}
    "in" -> IdDz {reject}
    "<<Int" -> IdDz {reject}
    "#EBADF" -> IdDz {reject}
    "Float2String" -> IdDz {reject}
    "decomposeMatching" -> IdDz {reject}
    "|->" -> IdDz {reject}
    "isKLabelConstant" -> IdDz {reject}
    "isMatching" -> IdDz {reject}
    "/Float" -> IdDz {reject}
    "<=String" -> IdDz {reject}
    ">=String" -> IdDz {reject}
    "CellLabel2KLabel" -> IdDz {reject}
    "=KList" -> IdDz {reject}
    "String2Id" -> IdDz {reject}
    "#getMapFromK" -> IdDz {reject}
    "==Bool" -> IdDz {reject}
    "isSymbolicList" -> IdDz {reject}
    "divInt" -> IdDz {reject}
    "absInt" -> IdDz {reject}
    "Map" -> IdDz {reject}
    "#ENAMETOOLONG" -> IdDz {reject}
    "<=Float" -> IdDz {reject}
    "chrChar" -> IdDz {reject}
    "randomRandom" -> IdDz {reject}
    "wrap-with" -> IdDz {reject}
    "#set" -> IdDz {reject}
    "isEmptySet" -> IdDz {reject}
    "/Int" -> IdDz {reject}
    "==Int" -> IdDz {reject}
    "KList2KLabel" -> IdDz {reject}
    "#parseToken" -> IdDz {reject}
    "<String" -> IdDz {reject}
    "=/=String" -> IdDz {reject}
    "#hasMapping" -> IdDz {reject}
    "K2Sort" -> IdDz {reject}
    "#EACCES" -> IdDz {reject}
    "cool" -> IdDz {reject}
    "freeVariables" -> IdDz {reject}
    ">Float" -> IdDz {reject}
    "#rebind" -> IdDz {reject}
    "#boundVars" -> IdDz {reject}
    "*Int" -> IdDz {reject}
    "redex" -> IdDz {reject}
    "<=Map" -> IdDz {reject}
    "String2Float" -> IdDz {reject}
    "exists" -> IdDz {reject}
    "#freshSymN" -> IdDz {reject}
    "impliesBool" -> IdDz {reject}
    "SMTLibQuery" -> IdDz {reject}
    "andThenBool" -> IdDz {reject}
    "#rebind2" -> IdDz {reject}
    "#ENOENT" -> IdDz {reject}
    "#rebind1" -> IdDz {reject}
    "<=" -> IdDz {reject}
    "List2KLabel" -> IdDz {reject}
    ">>Int" -> IdDz {reject}
    "replace" -> IdDz {reject}
    "lengthList" -> IdDz {reject}
    "String2KLabel" -> IdDz {reject}
    "while" -> IdDz {reject}
    "#ELOOP" -> IdDz {reject}
    "isToken" -> IdDz {reject}
    "inVars" -> IdDz {reject}
    "substrString" -> IdDz {reject}
    "Vars2SMTLib" -> IdDz {reject}
    "#getSymLabel" -> IdDz {reject}
    "%Int" -> IdDz {reject}
    "+Float" -> IdDz {reject}
    "==Float" -> IdDz {reject}
    "countAllOccurences" -> IdDz {reject}
    "==" -> IdDz {reject}
    "KLabel2KLabel" -> IdDz {reject}
    "read" -> IdDz {reject}
    "#freshSym" -> IdDz {reject}
    "Int2String" -> IdDz {reject}
    "#substituteFV" -> IdDz {reject}
    "=K" -> IdDz {reject}
    "Consts2SMTLib" -> IdDz {reject}
    "true" -> IdDz {reject}
    "heated" -> IdDz {reject}
    "Char2String" -> IdDz {reject}
    "#substituteList" -> IdDz {reject}
    "=/=Set" -> IdDz {reject}
    "Set2KLabel" -> IdDz {reject}
    ">=" -> IdDz {reject}
    "heat" -> IdDz {reject}
    "#else" -> IdDz {reject}
    "=Map" -> IdDz {reject}
    "<=Int" -> IdDz {reject}
    "String2Char" -> IdDz {reject}
    "modInt" -> IdDz {reject}
    "minInt" -> IdDz {reject}
    "keys" -> IdDz {reject}
    "values" -> IdDz {reject}
    "orElseBool" -> IdDz {reject}
    "==List" -> IdDz {reject}
    "#EOF" -> IdDz {reject}
    "#freeVarsSet" -> IdDz {reject}
    "'#andBool" -> IdDz {reject}
    "=/=KLabel" -> IdDz {reject}
    "=/=Int" -> IdDz {reject}
    "+Int" -> IdDz {reject}
    "findChar" -> IdDz {reject}
    "--Float" -> IdDz {reject}
    "and" -> IdDz {reject}
    "==Set" -> IdDz {reject}
    "#substituteList1" -> IdDz {reject}
    "#tcpRequest" -> IdDz {reject}
    "Id2String" -> IdDz {reject}
    "or" -> IdDz {reject}
    "#substitute" -> IdDz {reject}
    "#token" -> IdDz {reject}
    "rtrim" -> IdDz {reject}
    "|Int" -> IdDz {reject}
    "*Float" -> IdDz {reject}
    "inKList" -> IdDz {reject}
    "int" -> IdDz {reject}
    "<Float" -> IdDz {reject}
    "andBool" -> IdDz {reject}
    "spawn" -> IdDz {reject}
    "isVariable" -> IdDz {reject}
    "&Int" -> IdDz {reject}
    "#binderSplit" -> IdDz {reject}
    "#freshVar1" -> IdDz {reject}
    "#substituteKArrow" -> IdDz {reject}
    "directionalityChar" -> DzIntDz {reject}
    "%Float" -> DzIntDz {reject}
    "#getVarsFromK" -> DzIntDz {reject}
    "<Int" -> DzIntDz {reject}
    ">String" -> DzIntDz {reject}
    "trim" -> DzIntDz {reject}
    "categoryChar" -> DzIntDz {reject}
    "isSymbolicSet" -> DzIntDz {reject}
    "#evalHelper" -> DzIntDz {reject}
    "isBinder" -> DzIntDz {reject}
    "#substituteBinder" -> DzIntDz {reject}
    "#binderSplit1" -> DzIntDz {reject}
    "vars" -> DzIntDz {reject}
    "#binderSplit2" -> DzIntDz {reject}
    "#freeVars1" -> DzIntDz {reject}
    "!" -> DzIntDz {reject}
    "#" -> DzIntDz {reject}
    "checkSat" -> DzIntDz {reject}
    "%" -> DzIntDz {reject}
    "#fi" -> DzIntDz {reject}
    "(" -> DzIntDz {reject}
    ")" -> DzIntDz {reject}
    "ordChar" -> DzIntDz {reject}
    "*" -> DzIntDz {reject}
    "+" -> DzIntDz {reject}
    "," -> DzIntDz {reject}
    "-" -> DzIntDz {reject}
    "." -> DzIntDz {reject}
    "Int2Float" -> DzIntDz {reject}
    "/" -> DzIntDz {reject}
    "#inKList" -> DzIntDz {reject}
    "getKLabel" -> DzIntDz {reject}
    ">=Int" -> DzIntDz {reject}
    "=/=KList" -> DzIntDz {reject}
    "semaphore" -> DzIntDz {reject}
    ">=Float" -> DzIntDz {reject}
    ";" -> DzIntDz {reject}
    "<" -> DzIntDz {reject}
    "!=" -> DzIntDz {reject}
    "isLocalFreshVar" -> DzIntDz {reject}
    "=" -> DzIntDz {reject}
    ">" -> DzIntDz {reject}
    "#symEqualitySort" -> DzIntDz {reject}
    "getVariables" -> DzIntDz {reject}
    "#freshVar" -> DzIntDz {reject}
    "#tcpError" -> DzIntDz {reject}
    "#map" -> DzIntDz {reject}
    "replaceFirst" -> DzIntDz {reject}
    "<=Set" -> DzIntDz {reject}
    "isBounding" -> DzIntDz {reject}
    "KLabel2String" -> DzIntDz {reject}
    "#getVars" -> DzIntDz {reject}
    "#getVars1" -> DzIntDz {reject}
    "[" -> DzIntDz {reject}
    "]" -> DzIntDz {reject}
    "xorBool" -> DzIntDz {reject}
    "#substitutePlainList" -> DzIntDz {reject}
    "maxInt" -> DzIntDz {reject}
    "forall" -> DzIntDz {reject}
    "undef" -> DzIntDz {reject}
    "=Int" -> DzIntDz {reject}
    "==String" -> DzIntDz {reject}
    "#freeVars" -> DzIntDz {reject}
    "SMTCall" -> DzIntDz {reject}
    "#freshSubst1" -> DzIntDz {reject}
    "#noparse" -> DzIntDz {reject}
    "#boundVars1" -> DzIntDz {reject}
    "#patternMatch1" -> DzIntDz {reject}
    "{" -> DzIntDz {reject}
    "}" -> DzIntDz {reject}
    "isKResult" -> DzIntDz {reject}
    "#if" -> DzIntDz {reject}
    "xorInt" -> DzIntDz {reject}
    "notBool" -> DzIntDz {reject}
    "Map2KLabel" -> DzIntDz {reject}
    "#freeVarsBinder" -> DzIntDz {reject}
    "-Int" -> DzIntDz {reject}
    "=Bag" -> DzIntDz {reject}
    "#freshSymSort" -> DzIntDz {reject}
    "lengthString" -> DzIntDz {reject}
    "#counter" -> DzIntDz {reject}
    "##tcpRequest" -> DzIntDz {reject}
    "^Int" -> DzIntDz {reject}
    "#freeVarsBinder1" -> DzIntDz {reject}
    "#freeVarsBinder2" -> DzIntDz {reject}
    "#substituteBinder1" -> DzIntDz {reject}
    "#substituteBinder2" -> DzIntDz {reject}
    "#substMap" -> DzIntDz {reject}
    "#isTCPError" -> DzIntDz {reject}
    "#EISDIR" -> DzIntDz {reject}
    "unlock" -> DzIntDz {reject}
    "#isMapInK" -> DzIntDz {reject}
    "ltrim" -> DzIntDz {reject}
    "=/=List" -> DzIntDz {reject}
    "#patternMatch" -> DzIntDz {reject}
    "~Int" -> DzIntDz {reject}
    "==K" -> DzIntDz {reject}
    "isBuiltin" -> DzIntDz {reject}
    "#ENOTDIR" -> DzIntDz {reject}
    "#freshSymSortN" -> DzIntDz {reject}
    "#changeLabel" -> DzIntDz {reject}
    "=/=Map" -> DzIntDz {reject}
    "orBool" -> DzIntDz {reject}
    "isSymbolicBag" -> DzIntDz {reject}
    "$hasMapping" -> DzIntDz {reject}
    "#isDigit" -> DzIntDz {reject}
    ">Int" -> DzIntDz {reject}
    "replaceAll" -> DzIntDz {reject}
    "#ESPIPE" -> DzIntDz {reject}
    "==KList" -> DzIntDz {reject}
    "==KLabel" -> DzIntDz {reject}
    "=KLabel" -> DzIntDz {reject}
    "Set2KTerm" -> DzIntDz {reject}
    "rfindChar" -> DzIntDz {reject}
    "#isWhiteSpace" -> DzIntDz {reject}
    "=/=K" -> DzIntDz {reject}
    "intersectSet" -> DzIntDz {reject}
    "-Set" -> DzIntDz {reject}
    "#tokenToString" -> DzIntDz {reject}
    "#then" -> DzIntDz {reject}
    "#splitedBinder" -> DzIntDz {reject}
    "==Map" -> DzIntDz {reject}
    "#substituteK" -> DzIntDz {reject}
    "false" -> DzIntDz {reject}
    "^Float" -> DzIntDz {reject}
    "String2Int" -> DzIntDz {reject}
    "#freshSubst" -> DzIntDz {reject}
    "print" -> DzIntDz {reject}
    "#freezer" -> DzIntDz {reject}
    "isBound" -> DzIntDz {reject}
    "Bag2KLabel" -> DzIntDz {reject}
    "-Float" -> DzIntDz {reject}
    "#distinctCounter" -> DzIntDz {reject}
    "=Set" -> DzIntDz {reject}
    "+String" -> DzIntDz {reject}
    "#substitutePlainList1" -> DzIntDz {reject}
    "fresh" -> DzIntDz {reject}
    "=/=Bool" -> DzIntDz {reject}
    "getMatching" -> DzIntDz {reject}
    "K2SMTLib" -> DzIntDz {reject}
    "=List" -> DzIntDz {reject}
    "#checkTCPAnswer" -> DzIntDz {reject}
    "rfindString" -> DzIntDz {reject}
    "#substitutePlain" -> DzIntDz {reject}
    "#inSet" -> DzIntDz {reject}
    "freshVariables" -> DzIntDz {reject}
    "Float2Int" -> DzIntDz {reject}
    "dummy" -> DzIntDz {reject}
    "isSymbolicMap" -> DzIntDz {reject}
    "Set2KTermAcc" -> DzIntDz {reject}
    "#retrieveTCPError" -> DzIntDz {reject}
    "findString" -> DzIntDz {reject}
    "dividesInt" -> DzIntDz {reject}
    "else" -> DzIntDz {reject}
    "lock" -> DzIntDz {reject}
    "#EINVAL" -> DzIntDz {reject}
    "if" -> DzIntDz {reject}
    "=/=Float" -> DzIntDz {reject}
    "#eval" -> DzIntDz {reject}
    "isSet" -> DzIntDz {reject}
    "in" -> DzIntDz {reject}
    "<<Int" -> DzIntDz {reject}
    "#EBADF" -> DzIntDz {reject}
    "Float2String" -> DzIntDz {reject}
    "decomposeMatching" -> DzIntDz {reject}
    "|->" -> DzIntDz {reject}
    "isKLabelConstant" -> DzIntDz {reject}
    "isMatching" -> DzIntDz {reject}
    "/Float" -> DzIntDz {reject}
    "<=String" -> DzIntDz {reject}
    ">=String" -> DzIntDz {reject}
    "CellLabel2KLabel" -> DzIntDz {reject}
    "=KList" -> DzIntDz {reject}
    "String2Id" -> DzIntDz {reject}
    "#getMapFromK" -> DzIntDz {reject}
    "==Bool" -> DzIntDz {reject}
    "isSymbolicList" -> DzIntDz {reject}
    "divInt" -> DzIntDz {reject}
    "absInt" -> DzIntDz {reject}
    "Map" -> DzIntDz {reject}
    "#ENAMETOOLONG" -> DzIntDz {reject}
    "<=Float" -> DzIntDz {reject}
    "chrChar" -> DzIntDz {reject}
    "randomRandom" -> DzIntDz {reject}
    "wrap-with" -> DzIntDz {reject}
    "#set" -> DzIntDz {reject}
    "isEmptySet" -> DzIntDz {reject}
    "/Int" -> DzIntDz {reject}
    "==Int" -> DzIntDz {reject}
    "KList2KLabel" -> DzIntDz {reject}
    "#parseToken" -> DzIntDz {reject}
    "<String" -> DzIntDz {reject}
    "=/=String" -> DzIntDz {reject}
    "#hasMapping" -> DzIntDz {reject}
    "K2Sort" -> DzIntDz {reject}
    "#EACCES" -> DzIntDz {reject}
    "cool" -> DzIntDz {reject}
    "freeVariables" -> DzIntDz {reject}
    ">Float" -> DzIntDz {reject}
    "#rebind" -> DzIntDz {reject}
    "#boundVars" -> DzIntDz {reject}
    "*Int" -> DzIntDz {reject}
    "redex" -> DzIntDz {reject}
    "<=Map" -> DzIntDz {reject}
    "String2Float" -> DzIntDz {reject}
    "exists" -> DzIntDz {reject}
    "#freshSymN" -> DzIntDz {reject}
    "impliesBool" -> DzIntDz {reject}
    "SMTLibQuery" -> DzIntDz {reject}
    "andThenBool" -> DzIntDz {reject}
    "#rebind2" -> DzIntDz {reject}
    "#ENOENT" -> DzIntDz {reject}
    "#rebind1" -> DzIntDz {reject}
    "<=" -> DzIntDz {reject}
    "List2KLabel" -> DzIntDz {reject}
    ">>Int" -> DzIntDz {reject}
    "replace" -> DzIntDz {reject}
    "lengthList" -> DzIntDz {reject}
    "String2KLabel" -> DzIntDz {reject}
    "while" -> DzIntDz {reject}
    "#ELOOP" -> DzIntDz {reject}
    "isToken" -> DzIntDz {reject}
    "inVars" -> DzIntDz {reject}
    "substrString" -> DzIntDz {reject}
    "Vars2SMTLib" -> DzIntDz {reject}
    "#getSymLabel" -> DzIntDz {reject}
    "%Int" -> DzIntDz {reject}
    "+Float" -> DzIntDz {reject}
    "==Float" -> DzIntDz {reject}
    "countAllOccurences" -> DzIntDz {reject}
    "==" -> DzIntDz {reject}
    "KLabel2KLabel" -> DzIntDz {reject}
    "read" -> DzIntDz {reject}
    "#freshSym" -> DzIntDz {reject}
    "Int2String" -> DzIntDz {reject}
    "#substituteFV" -> DzIntDz {reject}
    "=K" -> DzIntDz {reject}
    "Consts2SMTLib" -> DzIntDz {reject}
    "true" -> DzIntDz {reject}
    "heated" -> DzIntDz {reject}
    "Char2String" -> DzIntDz {reject}
    "#substituteList" -> DzIntDz {reject}
    "=/=Set" -> DzIntDz {reject}
    "Set2KLabel" -> DzIntDz {reject}
    ">=" -> DzIntDz {reject}
    "heat" -> DzIntDz {reject}
    "#else" -> DzIntDz {reject}
    "=Map" -> DzIntDz {reject}
    "<=Int" -> DzIntDz {reject}
    "String2Char" -> DzIntDz {reject}
    "modInt" -> DzIntDz {reject}
    "minInt" -> DzIntDz {reject}
    "keys" -> DzIntDz {reject}
    "values" -> DzIntDz {reject}
    "orElseBool" -> DzIntDz {reject}
    "==List" -> DzIntDz {reject}
    "#EOF" -> DzIntDz {reject}
    "#freeVarsSet" -> DzIntDz {reject}
    "'#andBool" -> DzIntDz {reject}
    "=/=KLabel" -> DzIntDz {reject}
    "=/=Int" -> DzIntDz {reject}
    "+Int" -> DzIntDz {reject}
    "findChar" -> DzIntDz {reject}
    "--Float" -> DzIntDz {reject}
    "and" -> DzIntDz {reject}
    "==Set" -> DzIntDz {reject}
    "#substituteList1" -> DzIntDz {reject}
    "#tcpRequest" -> DzIntDz {reject}
    "Id2String" -> DzIntDz {reject}
    "or" -> DzIntDz {reject}
    "#substitute" -> DzIntDz {reject}
    "#token" -> DzIntDz {reject}
    "rtrim" -> DzIntDz {reject}
    "|Int" -> DzIntDz {reject}
    "*Float" -> DzIntDz {reject}
    "inKList" -> DzIntDz {reject}
    "int" -> DzIntDz {reject}
    "<Float" -> DzIntDz {reject}
    "andBool" -> DzIntDz {reject}
    "spawn" -> DzIntDz {reject}
    "isVariable" -> DzIntDz {reject}
    "&Int" -> DzIntDz {reject}
    "#binderSplit" -> DzIntDz {reject}
    "#freshVar1" -> DzIntDz {reject}
    "#substituteKArrow" -> DzIntDz {reject}
    "directionalityChar" -> DzFloatDz {reject}
    "%Float" -> DzFloatDz {reject}
    "#getVarsFromK" -> DzFloatDz {reject}
    "<Int" -> DzFloatDz {reject}
    ">String" -> DzFloatDz {reject}
    "trim" -> DzFloatDz {reject}
    "categoryChar" -> DzFloatDz {reject}
    "isSymbolicSet" -> DzFloatDz {reject}
    "#evalHelper" -> DzFloatDz {reject}
    "isBinder" -> DzFloatDz {reject}
    "#substituteBinder" -> DzFloatDz {reject}
    "#binderSplit1" -> DzFloatDz {reject}
    "vars" -> DzFloatDz {reject}
    "#binderSplit2" -> DzFloatDz {reject}
    "#freeVars1" -> DzFloatDz {reject}
    "!" -> DzFloatDz {reject}
    "#" -> DzFloatDz {reject}
    "checkSat" -> DzFloatDz {reject}
    "%" -> DzFloatDz {reject}
    "#fi" -> DzFloatDz {reject}
    "(" -> DzFloatDz {reject}
    ")" -> DzFloatDz {reject}
    "ordChar" -> DzFloatDz {reject}
    "*" -> DzFloatDz {reject}
    "+" -> DzFloatDz {reject}
    "," -> DzFloatDz {reject}
    "-" -> DzFloatDz {reject}
    "." -> DzFloatDz {reject}
    "Int2Float" -> DzFloatDz {reject}
    "/" -> DzFloatDz {reject}
    "#inKList" -> DzFloatDz {reject}
    "getKLabel" -> DzFloatDz {reject}
    ">=Int" -> DzFloatDz {reject}
    "=/=KList" -> DzFloatDz {reject}
    "semaphore" -> DzFloatDz {reject}
    ">=Float" -> DzFloatDz {reject}
    ";" -> DzFloatDz {reject}
    "<" -> DzFloatDz {reject}
    "!=" -> DzFloatDz {reject}
    "isLocalFreshVar" -> DzFloatDz {reject}
    "=" -> DzFloatDz {reject}
    ">" -> DzFloatDz {reject}
    "#symEqualitySort" -> DzFloatDz {reject}
    "getVariables" -> DzFloatDz {reject}
    "#freshVar" -> DzFloatDz {reject}
    "#tcpError" -> DzFloatDz {reject}
    "#map" -> DzFloatDz {reject}
    "replaceFirst" -> DzFloatDz {reject}
    "<=Set" -> DzFloatDz {reject}
    "isBounding" -> DzFloatDz {reject}
    "KLabel2String" -> DzFloatDz {reject}
    "#getVars" -> DzFloatDz {reject}
    "#getVars1" -> DzFloatDz {reject}
    "[" -> DzFloatDz {reject}
    "]" -> DzFloatDz {reject}
    "xorBool" -> DzFloatDz {reject}
    "#substitutePlainList" -> DzFloatDz {reject}
    "maxInt" -> DzFloatDz {reject}
    "forall" -> DzFloatDz {reject}
    "undef" -> DzFloatDz {reject}
    "=Int" -> DzFloatDz {reject}
    "==String" -> DzFloatDz {reject}
    "#freeVars" -> DzFloatDz {reject}
    "SMTCall" -> DzFloatDz {reject}
    "#freshSubst1" -> DzFloatDz {reject}
    "#noparse" -> DzFloatDz {reject}
    "#boundVars1" -> DzFloatDz {reject}
    "#patternMatch1" -> DzFloatDz {reject}
    "{" -> DzFloatDz {reject}
    "}" -> DzFloatDz {reject}
    "isKResult" -> DzFloatDz {reject}
    "#if" -> DzFloatDz {reject}
    "xorInt" -> DzFloatDz {reject}
    "notBool" -> DzFloatDz {reject}
    "Map2KLabel" -> DzFloatDz {reject}
    "#freeVarsBinder" -> DzFloatDz {reject}
    "-Int" -> DzFloatDz {reject}
    "=Bag" -> DzFloatDz {reject}
    "#freshSymSort" -> DzFloatDz {reject}
    "lengthString" -> DzFloatDz {reject}
    "#counter" -> DzFloatDz {reject}
    "##tcpRequest" -> DzFloatDz {reject}
    "^Int" -> DzFloatDz {reject}
    "#freeVarsBinder1" -> DzFloatDz {reject}
    "#freeVarsBinder2" -> DzFloatDz {reject}
    "#substituteBinder1" -> DzFloatDz {reject}
    "#substituteBinder2" -> DzFloatDz {reject}
    "#substMap" -> DzFloatDz {reject}
    "#isTCPError" -> DzFloatDz {reject}
    "#EISDIR" -> DzFloatDz {reject}
    "unlock" -> DzFloatDz {reject}
    "#isMapInK" -> DzFloatDz {reject}
    "ltrim" -> DzFloatDz {reject}
    "=/=List" -> DzFloatDz {reject}
    "#patternMatch" -> DzFloatDz {reject}
    "~Int" -> DzFloatDz {reject}
    "==K" -> DzFloatDz {reject}
    "isBuiltin" -> DzFloatDz {reject}
    "#ENOTDIR" -> DzFloatDz {reject}
    "#freshSymSortN" -> DzFloatDz {reject}
    "#changeLabel" -> DzFloatDz {reject}
    "=/=Map" -> DzFloatDz {reject}
    "orBool" -> DzFloatDz {reject}
    "isSymbolicBag" -> DzFloatDz {reject}
    "$hasMapping" -> DzFloatDz {reject}
    "#isDigit" -> DzFloatDz {reject}
    ">Int" -> DzFloatDz {reject}
    "replaceAll" -> DzFloatDz {reject}
    "#ESPIPE" -> DzFloatDz {reject}
    "==KList" -> DzFloatDz {reject}
    "==KLabel" -> DzFloatDz {reject}
    "=KLabel" -> DzFloatDz {reject}
    "Set2KTerm" -> DzFloatDz {reject}
    "rfindChar" -> DzFloatDz {reject}
    "#isWhiteSpace" -> DzFloatDz {reject}
    "=/=K" -> DzFloatDz {reject}
    "intersectSet" -> DzFloatDz {reject}
    "-Set" -> DzFloatDz {reject}
    "#tokenToString" -> DzFloatDz {reject}
    "#then" -> DzFloatDz {reject}
    "#splitedBinder" -> DzFloatDz {reject}
    "==Map" -> DzFloatDz {reject}
    "#substituteK" -> DzFloatDz {reject}
    "false" -> DzFloatDz {reject}
    "^Float" -> DzFloatDz {reject}
    "String2Int" -> DzFloatDz {reject}
    "#freshSubst" -> DzFloatDz {reject}
    "print" -> DzFloatDz {reject}
    "#freezer" -> DzFloatDz {reject}
    "isBound" -> DzFloatDz {reject}
    "Bag2KLabel" -> DzFloatDz {reject}
    "-Float" -> DzFloatDz {reject}
    "#distinctCounter" -> DzFloatDz {reject}
    "=Set" -> DzFloatDz {reject}
    "+String" -> DzFloatDz {reject}
    "#substitutePlainList1" -> DzFloatDz {reject}
    "fresh" -> DzFloatDz {reject}
    "=/=Bool" -> DzFloatDz {reject}
    "getMatching" -> DzFloatDz {reject}
    "K2SMTLib" -> DzFloatDz {reject}
    "=List" -> DzFloatDz {reject}
    "#checkTCPAnswer" -> DzFloatDz {reject}
    "rfindString" -> DzFloatDz {reject}
    "#substitutePlain" -> DzFloatDz {reject}
    "#inSet" -> DzFloatDz {reject}
    "freshVariables" -> DzFloatDz {reject}
    "Float2Int" -> DzFloatDz {reject}
    "dummy" -> DzFloatDz {reject}
    "isSymbolicMap" -> DzFloatDz {reject}
    "Set2KTermAcc" -> DzFloatDz {reject}
    "#retrieveTCPError" -> DzFloatDz {reject}
    "findString" -> DzFloatDz {reject}
    "dividesInt" -> DzFloatDz {reject}
    "else" -> DzFloatDz {reject}
    "lock" -> DzFloatDz {reject}
    "#EINVAL" -> DzFloatDz {reject}
    "if" -> DzFloatDz {reject}
    "=/=Float" -> DzFloatDz {reject}
    "#eval" -> DzFloatDz {reject}
    "isSet" -> DzFloatDz {reject}
    "in" -> DzFloatDz {reject}
    "<<Int" -> DzFloatDz {reject}
    "#EBADF" -> DzFloatDz {reject}
    "Float2String" -> DzFloatDz {reject}
    "decomposeMatching" -> DzFloatDz {reject}
    "|->" -> DzFloatDz {reject}
    "isKLabelConstant" -> DzFloatDz {reject}
    "isMatching" -> DzFloatDz {reject}
    "/Float" -> DzFloatDz {reject}
    "<=String" -> DzFloatDz {reject}
    ">=String" -> DzFloatDz {reject}
    "CellLabel2KLabel" -> DzFloatDz {reject}
    "=KList" -> DzFloatDz {reject}
    "String2Id" -> DzFloatDz {reject}
    "#getMapFromK" -> DzFloatDz {reject}
    "==Bool" -> DzFloatDz {reject}
    "isSymbolicList" -> DzFloatDz {reject}
    "divInt" -> DzFloatDz {reject}
    "absInt" -> DzFloatDz {reject}
    "Map" -> DzFloatDz {reject}
    "#ENAMETOOLONG" -> DzFloatDz {reject}
    "<=Float" -> DzFloatDz {reject}
    "chrChar" -> DzFloatDz {reject}
    "randomRandom" -> DzFloatDz {reject}
    "wrap-with" -> DzFloatDz {reject}
    "#set" -> DzFloatDz {reject}
    "isEmptySet" -> DzFloatDz {reject}
    "/Int" -> DzFloatDz {reject}
    "==Int" -> DzFloatDz {reject}
    "KList2KLabel" -> DzFloatDz {reject}
    "#parseToken" -> DzFloatDz {reject}
    "<String" -> DzFloatDz {reject}
    "=/=String" -> DzFloatDz {reject}
    "#hasMapping" -> DzFloatDz {reject}
    "K2Sort" -> DzFloatDz {reject}
    "#EACCES" -> DzFloatDz {reject}
    "cool" -> DzFloatDz {reject}
    "freeVariables" -> DzFloatDz {reject}
    ">Float" -> DzFloatDz {reject}
    "#rebind" -> DzFloatDz {reject}
    "#boundVars" -> DzFloatDz {reject}
    "*Int" -> DzFloatDz {reject}
    "redex" -> DzFloatDz {reject}
    "<=Map" -> DzFloatDz {reject}
    "String2Float" -> DzFloatDz {reject}
    "exists" -> DzFloatDz {reject}
    "#freshSymN" -> DzFloatDz {reject}
    "impliesBool" -> DzFloatDz {reject}
    "SMTLibQuery" -> DzFloatDz {reject}
    "andThenBool" -> DzFloatDz {reject}
    "#rebind2" -> DzFloatDz {reject}
    "#ENOENT" -> DzFloatDz {reject}
    "#rebind1" -> DzFloatDz {reject}
    "<=" -> DzFloatDz {reject}
    "List2KLabel" -> DzFloatDz {reject}
    ">>Int" -> DzFloatDz {reject}
    "replace" -> DzFloatDz {reject}
    "lengthList" -> DzFloatDz {reject}
    "String2KLabel" -> DzFloatDz {reject}
    "while" -> DzFloatDz {reject}
    "#ELOOP" -> DzFloatDz {reject}
    "isToken" -> DzFloatDz {reject}
    "inVars" -> DzFloatDz {reject}
    "substrString" -> DzFloatDz {reject}
    "Vars2SMTLib" -> DzFloatDz {reject}
    "#getSymLabel" -> DzFloatDz {reject}
    "%Int" -> DzFloatDz {reject}
    "+Float" -> DzFloatDz {reject}
    "==Float" -> DzFloatDz {reject}
    "countAllOccurences" -> DzFloatDz {reject}
    "==" -> DzFloatDz {reject}
    "KLabel2KLabel" -> DzFloatDz {reject}
    "read" -> DzFloatDz {reject}
    "#freshSym" -> DzFloatDz {reject}
    "Int2String" -> DzFloatDz {reject}
    "#substituteFV" -> DzFloatDz {reject}
    "=K" -> DzFloatDz {reject}
    "Consts2SMTLib" -> DzFloatDz {reject}
    "true" -> DzFloatDz {reject}
    "heated" -> DzFloatDz {reject}
    "Char2String" -> DzFloatDz {reject}
    "#substituteList" -> DzFloatDz {reject}
    "=/=Set" -> DzFloatDz {reject}
    "Set2KLabel" -> DzFloatDz {reject}
    ">=" -> DzFloatDz {reject}
    "heat" -> DzFloatDz {reject}
    "#else" -> DzFloatDz {reject}
    "=Map" -> DzFloatDz {reject}
    "<=Int" -> DzFloatDz {reject}
    "String2Char" -> DzFloatDz {reject}
    "modInt" -> DzFloatDz {reject}
    "minInt" -> DzFloatDz {reject}
    "keys" -> DzFloatDz {reject}
    "values" -> DzFloatDz {reject}
    "orElseBool" -> DzFloatDz {reject}
    "==List" -> DzFloatDz {reject}
    "#EOF" -> DzFloatDz {reject}
    "#freeVarsSet" -> DzFloatDz {reject}
    "'#andBool" -> DzFloatDz {reject}
    "=/=KLabel" -> DzFloatDz {reject}
    "=/=Int" -> DzFloatDz {reject}
    "+Int" -> DzFloatDz {reject}
    "findChar" -> DzFloatDz {reject}
    "--Float" -> DzFloatDz {reject}
    "and" -> DzFloatDz {reject}
    "==Set" -> DzFloatDz {reject}
    "#substituteList1" -> DzFloatDz {reject}
    "#tcpRequest" -> DzFloatDz {reject}
    "Id2String" -> DzFloatDz {reject}
    "or" -> DzFloatDz {reject}
    "#substitute" -> DzFloatDz {reject}
    "#token" -> DzFloatDz {reject}
    "rtrim" -> DzFloatDz {reject}
    "|Int" -> DzFloatDz {reject}
    "*Float" -> DzFloatDz {reject}
    "inKList" -> DzFloatDz {reject}
    "int" -> DzFloatDz {reject}
    "<Float" -> DzFloatDz {reject}
    "andBool" -> DzFloatDz {reject}
    "spawn" -> DzFloatDz {reject}
    "isVariable" -> DzFloatDz {reject}
    "&Int" -> DzFloatDz {reject}
    "#binderSplit" -> DzFloatDz {reject}
    "#freshVar1" -> DzFloatDz {reject}
    "#substituteKArrow" -> DzFloatDz {reject}
context-free syntax
    DzStringDz -> DzString {cons("DzString1Const")}
    IdDz -> Id {cons("Id1Const")}
    DzIntDz -> DzInt {cons("DzInt1Const")}
    DzFloatDz -> DzFloat {cons("DzFloat1Const")}


context-free restrictions
    "#" -/- [s].[y].[m]
    DzInt -/- [0-9]
    Id -/- [A-Za-z0-9\_]
